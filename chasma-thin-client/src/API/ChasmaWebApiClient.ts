//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class HealthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:44349";
    }

    getHeartbeat(): Promise<HeartbeatMessage> {
        let url_ = this.baseUrl + "/api/Health/heartbeat";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHeartbeat(_response);
        });
    }

    protected processGetHeartbeat(response: Response): Promise<HeartbeatMessage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HeartbeatMessage.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HeartbeatMessage>(null as any);
    }
}

export class JwtClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:44349";
    }

    encodeJwt(encodeJwtRequest: EncodeJwtRequest): Promise<EncodeJwtResponse> {
        let url_ = this.baseUrl + "/api/encodeJwt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(encodeJwtRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEncodeJwt(_response);
        });
    }

    protected processEncodeJwt(response: Response): Promise<EncodeJwtResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EncodeJwtResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EncodeJwtResponse>(null as any);
    }

    decodeJwt(decodeJwtRequest: DecodeJwtRequest): Promise<DecodeJwtResponse> {
        let url_ = this.baseUrl + "/api/decodeJwt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(decodeJwtRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDecodeJwt(_response);
        });
    }

    protected processDecodeJwt(response: Response): Promise<DecodeJwtResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DecodeJwtResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DecodeJwtResponse>(null as any);
    }
}

export class UuidClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:44349";
    }

    generateUuid(): Promise<string> {
        let url_ = this.baseUrl + "/api/uuid";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateUuid(_response);
        });
    }

    protected processGenerateUuid(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class HeartbeatMessage implements IHeartbeatMessage {
    message?: string;
    status?: HeartbeatStatus;

    constructor(data?: IHeartbeatMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): HeartbeatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new HeartbeatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["status"] = this.status;
        return data;
    }
}

export interface IHeartbeatMessage {
    message?: string;
    status?: HeartbeatStatus;
}

export enum HeartbeatStatus {
    Ok = 0,
    Error = 1,
}

export class ChasmaXmlBase implements IChasmaXmlBase {

    constructor(data?: IChasmaXmlBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ChasmaXmlBase {
        data = typeof data === 'object' ? data : {};
        let result = new ChasmaXmlBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IChasmaXmlBase {
}

export class ResponseBase extends ChasmaXmlBase implements IResponseBase {
    isErrorResponse?: boolean;
    errorMessage?: string | undefined;

    constructor(data?: IResponseBase) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isErrorResponse = _data["isErrorResponse"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): ResponseBase {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isErrorResponse"] = this.isErrorResponse;
        data["errorMessage"] = this.errorMessage;
        super.toJSON(data);
        return data;
    }
}

export interface IResponseBase extends IChasmaXmlBase {
    isErrorResponse?: boolean;
    errorMessage?: string | undefined;
}

export class EncodeJwtResponse extends ResponseBase implements IEncodeJwtResponse {
    token?: string;
    expirationTime?: Date;

    constructor(data?: IEncodeJwtResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.token = _data["token"];
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): EncodeJwtResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EncodeJwtResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : undefined as any;
        super.toJSON(data);
        return data;
    }
}

export interface IEncodeJwtResponse extends IResponseBase {
    token?: string;
    expirationTime?: Date;
}

export class EncodeJwtRequest implements IEncodeJwtRequest {
    secretKey?: string;
    username?: string;
    name?: string;
    role?: string;
    audience?: string;
    issuer?: string;
    customClaimTypes?: string[];
    customClaimValues?: string[];
    expireInMinutes?: number;

    constructor(data?: IEncodeJwtRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.secretKey = _data["secretKey"];
            this.username = _data["username"];
            this.name = _data["name"];
            this.role = _data["role"];
            this.audience = _data["audience"];
            this.issuer = _data["issuer"];
            if (Array.isArray(_data["customClaimTypes"])) {
                this.customClaimTypes = [] as any;
                for (let item of _data["customClaimTypes"])
                    this.customClaimTypes!.push(item);
            }
            if (Array.isArray(_data["customClaimValues"])) {
                this.customClaimValues = [] as any;
                for (let item of _data["customClaimValues"])
                    this.customClaimValues!.push(item);
            }
            this.expireInMinutes = _data["expireInMinutes"];
        }
    }

    static fromJS(data: any): EncodeJwtRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EncodeJwtRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secretKey"] = this.secretKey;
        data["username"] = this.username;
        data["name"] = this.name;
        data["role"] = this.role;
        data["audience"] = this.audience;
        data["issuer"] = this.issuer;
        if (Array.isArray(this.customClaimTypes)) {
            data["customClaimTypes"] = [];
            for (let item of this.customClaimTypes)
                data["customClaimTypes"].push(item);
        }
        if (Array.isArray(this.customClaimValues)) {
            data["customClaimValues"] = [];
            for (let item of this.customClaimValues)
                data["customClaimValues"].push(item);
        }
        data["expireInMinutes"] = this.expireInMinutes;
        return data;
    }
}

export interface IEncodeJwtRequest {
    secretKey?: string;
    username?: string;
    name?: string;
    role?: string;
    audience?: string;
    issuer?: string;
    customClaimTypes?: string[];
    customClaimValues?: string[];
    expireInMinutes?: number;
}

export class DecodeJwtResponse extends ResponseBase implements IDecodeJwtResponse {
    decodedJwtTokenString?: string;
    isValidToken?: boolean;
    header?: JwtHeader;
    payload?: JwtPayload;
    claimTypes?: string[];
    claimValues?: string[];

    constructor(data?: IDecodeJwtResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.decodedJwtTokenString = _data["decodedJwtTokenString"];
            this.isValidToken = _data["isValidToken"];
            this.header = _data["header"] ? JwtHeader.fromJS(_data["header"]) : undefined as any;
            this.payload = _data["payload"] ? JwtPayload.fromJS(_data["payload"]) : undefined as any;
            if (Array.isArray(_data["claimTypes"])) {
                this.claimTypes = [] as any;
                for (let item of _data["claimTypes"])
                    this.claimTypes!.push(item);
            }
            if (Array.isArray(_data["claimValues"])) {
                this.claimValues = [] as any;
                for (let item of _data["claimValues"])
                    this.claimValues!.push(item);
            }
        }
    }

    static fromJS(data: any): DecodeJwtResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DecodeJwtResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["decodedJwtTokenString"] = this.decodedJwtTokenString;
        data["isValidToken"] = this.isValidToken;
        data["header"] = this.header ? this.header.toJSON() : undefined as any;
        data["payload"] = this.payload ? this.payload.toJSON() : undefined as any;
        if (Array.isArray(this.claimTypes)) {
            data["claimTypes"] = [];
            for (let item of this.claimTypes)
                data["claimTypes"].push(item);
        }
        if (Array.isArray(this.claimValues)) {
            data["claimValues"] = [];
            for (let item of this.claimValues)
                data["claimValues"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDecodeJwtResponse extends IResponseBase {
    decodedJwtTokenString?: string;
    isValidToken?: boolean;
    header?: JwtHeader;
    payload?: JwtPayload;
    claimTypes?: string[];
    claimValues?: string[];
}

/** Initializes a new instance of JwtHeader which contains JSON objects representing the cryptographic operations applied to the JWT and optionally any additional properties of the JWT. The member names within the JWT Header are referred to as Header Parameter Names. These names MUST be unique and the values must be String(s). The corresponding values are referred to as Header Parameter Values. */
export class JwtHeader implements IJwtHeader {
    /** Gets the signature algorithm that was used to create the signature. */
    alg?: string | undefined;
    /** Gets the content mime type (Cty) of the token. */
    cty?: string | undefined;
    /** Gets the encryption algorithm (Enc) of the token. */
    enc?: string | undefined;
    /** Gets the EncryptingCredentials passed in the constructor. */
    encryptingCredentials?: EncryptingCredentials | undefined;
    /** Gets the iv of symmetric key wrap. */
    iv?: string | undefined;
    /** Gets the key identifier for the security key used to sign the token */
    kid?: string | undefined;
    /** Gets the SigningCredentials passed in the constructor. */
    signingCredentials?: SigningCredentials | undefined;
    /** Gets the mime type (Typ) of the token. */
    typ?: string | undefined;
    /** Gets the thumbprint of the certificate used to sign the token */
    x5t?: string | undefined;
    /** Gets the certificate used to sign the token */
    x5c?: string | undefined;
    /** Gets the 'value' of the 'zip' claim { zip, 'value' }. */
    zip?: string | undefined;

    [key: string]: any;

    constructor(data?: IJwtHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.alg = _data["alg"];
            this.cty = _data["cty"];
            this.enc = _data["enc"];
            this.encryptingCredentials = _data["encryptingCredentials"] ? EncryptingCredentials.fromJS(_data["encryptingCredentials"]) : undefined as any;
            this.iv = _data["iv"];
            this.kid = _data["kid"];
            this.signingCredentials = _data["signingCredentials"] ? SigningCredentials.fromJS(_data["signingCredentials"]) : undefined as any;
            this.typ = _data["typ"];
            this.x5t = _data["x5t"];
            this.x5c = _data["x5c"];
            this.zip = _data["zip"];
        }
    }

    static fromJS(data: any): JwtHeader {
        data = typeof data === 'object' ? data : {};
        let result = new JwtHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["alg"] = this.alg;
        data["cty"] = this.cty;
        data["enc"] = this.enc;
        data["encryptingCredentials"] = this.encryptingCredentials ? this.encryptingCredentials.toJSON() : undefined as any;
        data["iv"] = this.iv;
        data["kid"] = this.kid;
        data["signingCredentials"] = this.signingCredentials ? this.signingCredentials.toJSON() : undefined as any;
        data["typ"] = this.typ;
        data["x5t"] = this.x5t;
        data["x5c"] = this.x5c;
        data["zip"] = this.zip;
        return data;
    }
}

/** Initializes a new instance of JwtHeader which contains JSON objects representing the cryptographic operations applied to the JWT and optionally any additional properties of the JWT. The member names within the JWT Header are referred to as Header Parameter Names. These names MUST be unique and the values must be String(s). The corresponding values are referred to as Header Parameter Values. */
export interface IJwtHeader {
    /** Gets the signature algorithm that was used to create the signature. */
    alg?: string | undefined;
    /** Gets the content mime type (Cty) of the token. */
    cty?: string | undefined;
    /** Gets the encryption algorithm (Enc) of the token. */
    enc?: string | undefined;
    /** Gets the EncryptingCredentials passed in the constructor. */
    encryptingCredentials?: EncryptingCredentials | undefined;
    /** Gets the iv of symmetric key wrap. */
    iv?: string | undefined;
    /** Gets the key identifier for the security key used to sign the token */
    kid?: string | undefined;
    /** Gets the SigningCredentials passed in the constructor. */
    signingCredentials?: SigningCredentials | undefined;
    /** Gets the mime type (Typ) of the token. */
    typ?: string | undefined;
    /** Gets the thumbprint of the certificate used to sign the token */
    x5t?: string | undefined;
    /** Gets the certificate used to sign the token */
    x5c?: string | undefined;
    /** Gets the 'value' of the 'zip' claim { zip, 'value' }. */
    zip?: string | undefined;

    [key: string]: any;
}

/** A class for properties that are used for token encryption. */
export class EncryptingCredentials implements IEncryptingCredentials {
    /** Gets the key wrap algorithm used for session key encryption. */
    alg?: string | undefined;
    /** Gets the data encryption algorithm. */
    enc?: string | undefined;
    /** Gets or sets the public key used in Key Agreement Algorithms. */
    keyExchangePublicKey?: SecurityKey | undefined;
    /** Users can override the default CryptoProviderFactory with this property. This factory will be used for creating encryption providers. */
    cryptoProviderFactory?: CryptoProviderFactory | undefined;
    /** Gets or sets a bool that controls if the encrypted token creation will set default 'cty' if not specified. */
    setDefaultCtyClaim?: boolean;
    /** Gets the SecurityKey used for encryption. */
    key?: SecurityKey | undefined;

    constructor(data?: IEncryptingCredentials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alg = _data["alg"];
            this.enc = _data["enc"];
            this.keyExchangePublicKey = _data["keyExchangePublicKey"] ? SecurityKey.fromJS(_data["keyExchangePublicKey"]) : undefined as any;
            this.cryptoProviderFactory = _data["cryptoProviderFactory"] ? CryptoProviderFactory.fromJS(_data["cryptoProviderFactory"]) : undefined as any;
            this.setDefaultCtyClaim = _data["setDefaultCtyClaim"];
            this.key = _data["key"] ? SecurityKey.fromJS(_data["key"]) : undefined as any;
        }
    }

    static fromJS(data: any): EncryptingCredentials {
        data = typeof data === 'object' ? data : {};
        let result = new EncryptingCredentials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alg"] = this.alg;
        data["enc"] = this.enc;
        data["keyExchangePublicKey"] = this.keyExchangePublicKey ? this.keyExchangePublicKey.toJSON() : undefined as any;
        data["cryptoProviderFactory"] = this.cryptoProviderFactory ? this.cryptoProviderFactory.toJSON() : undefined as any;
        data["setDefaultCtyClaim"] = this.setDefaultCtyClaim;
        data["key"] = this.key ? this.key.toJSON() : undefined as any;
        return data;
    }
}

/** A class for properties that are used for token encryption. */
export interface IEncryptingCredentials {
    /** Gets the key wrap algorithm used for session key encryption. */
    alg?: string | undefined;
    /** Gets the data encryption algorithm. */
    enc?: string | undefined;
    /** Gets or sets the public key used in Key Agreement Algorithms. */
    keyExchangePublicKey?: SecurityKey | undefined;
    /** Users can override the default CryptoProviderFactory with this property. This factory will be used for creating encryption providers. */
    cryptoProviderFactory?: CryptoProviderFactory | undefined;
    /** Gets or sets a bool that controls if the encrypted token creation will set default 'cty' if not specified. */
    setDefaultCtyClaim?: boolean;
    /** Gets the SecurityKey used for encryption. */
    key?: SecurityKey | undefined;
}

/** Base class for Security Key. */
export abstract class SecurityKey implements ISecurityKey {
    /** This must be overridden to get the size of this SecurityKey. */
    keySize?: number;

    constructor(data?: ISecurityKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keySize = _data["keySize"];
        }
    }

    static fromJS(data: any): SecurityKey {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SecurityKey' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keySize"] = this.keySize;
        return data;
    }
}

/** Base class for Security Key. */
export interface ISecurityKey {
    /** This must be overridden to get the size of this SecurityKey. */
    keySize?: number;
}

/** Creates cryptographic operators by specifying a SecurityKey's and algorithms. */
export class CryptoProviderFactory implements ICryptoProviderFactory {
    /** Gets the CryptoProviderCache. */
    cryptoProviderCache?: CryptoProviderCache | undefined;
    /** Extensibility point for creating custom cryptographic operators. */
    customCryptoProvider?: ICryptoProvider | undefined;
    /** Gets or sets a bool controlling if SignatureProvider should be cached. */
    cacheSignatureProviders?: boolean;
    /** Gets or sets the maximum size of the object pool used by the SignatureProvider that are used for crypto objects. */
    signatureProviderObjectPoolCacheSize?: number;

    constructor(data?: ICryptoProviderFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.cacheSignatureProviders = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cryptoProviderCache = _data["cryptoProviderCache"] ? CryptoProviderCache.fromJS(_data["cryptoProviderCache"]) : undefined as any;
            this.customCryptoProvider = _data["customCryptoProvider"] ? ICryptoProvider.fromJS(_data["customCryptoProvider"]) : undefined as any;
            this.cacheSignatureProviders = _data["cacheSignatureProviders"] !== undefined ? _data["cacheSignatureProviders"] : true;
            this.signatureProviderObjectPoolCacheSize = _data["signatureProviderObjectPoolCacheSize"];
        }
    }

    static fromJS(data: any): CryptoProviderFactory {
        data = typeof data === 'object' ? data : {};
        let result = new CryptoProviderFactory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cryptoProviderCache"] = this.cryptoProviderCache ? this.cryptoProviderCache.toJSON() : undefined as any;
        data["customCryptoProvider"] = this.customCryptoProvider ? this.customCryptoProvider.toJSON() : undefined as any;
        data["cacheSignatureProviders"] = this.cacheSignatureProviders;
        data["signatureProviderObjectPoolCacheSize"] = this.signatureProviderObjectPoolCacheSize;
        return data;
    }
}

/** Creates cryptographic operators by specifying a SecurityKey's and algorithms. */
export interface ICryptoProviderFactory {
    /** Gets the CryptoProviderCache. */
    cryptoProviderCache?: CryptoProviderCache | undefined;
    /** Extensibility point for creating custom cryptographic operators. */
    customCryptoProvider?: ICryptoProvider | undefined;
    /** Gets or sets a bool controlling if SignatureProvider should be cached. */
    cacheSignatureProviders?: boolean;
    /** Gets or sets the maximum size of the object pool used by the SignatureProvider that are used for crypto objects. */
    signatureProviderObjectPoolCacheSize?: number;
}

/** Abstract definition of a cache for cryptographic providers. */
export abstract class CryptoProviderCache implements ICryptoProviderCache {

    constructor(data?: ICryptoProviderCache) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CryptoProviderCache {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CryptoProviderCache' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Abstract definition of a cache for cryptographic providers. */
export interface ICryptoProviderCache {
}

/** Provides extensibility for cryptographic operators. If custom operators are needed, CustomCryptoProvider can be set to return these operators. This property will be checked before each creation. */
export abstract class ICryptoProvider implements IICryptoProvider {

    constructor(data?: IICryptoProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICryptoProvider {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ICryptoProvider' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Provides extensibility for cryptographic operators. If custom operators are needed, CustomCryptoProvider can be set to return these operators. This property will be checked before each creation. */
export interface IICryptoProvider {
}

/** Defines the SecurityKey, algorithm and digest for digital signatures. */
export class SigningCredentials implements ISigningCredentials {
    /** Gets the signature algorithm. */
    algorithm?: string | undefined;
    /** Gets the digest algorithm. */
    digest?: string | undefined;
    /** Users can override the default CryptoProviderFactory with this property. This factory will be used for creating signature providers. */
    cryptoProviderFactory?: CryptoProviderFactory | undefined;
    /** Gets the SecurityKey used for signature creation or validation. */
    key?: SecurityKey | undefined;
    /** Gets the key id associated with SecurityKey. */
    kid?: string | undefined;

    constructor(data?: ISigningCredentials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.algorithm = _data["algorithm"];
            this.digest = _data["digest"];
            this.cryptoProviderFactory = _data["cryptoProviderFactory"] ? CryptoProviderFactory.fromJS(_data["cryptoProviderFactory"]) : undefined as any;
            this.key = _data["key"] ? SecurityKey.fromJS(_data["key"]) : undefined as any;
            this.kid = _data["kid"];
        }
    }

    static fromJS(data: any): SigningCredentials {
        data = typeof data === 'object' ? data : {};
        let result = new SigningCredentials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["algorithm"] = this.algorithm;
        data["digest"] = this.digest;
        data["cryptoProviderFactory"] = this.cryptoProviderFactory ? this.cryptoProviderFactory.toJSON() : undefined as any;
        data["key"] = this.key ? this.key.toJSON() : undefined as any;
        data["kid"] = this.kid;
        return data;
    }
}

/** Defines the SecurityKey, algorithm and digest for digital signatures. */
export interface ISigningCredentials {
    /** Gets the signature algorithm. */
    algorithm?: string | undefined;
    /** Gets the digest algorithm. */
    digest?: string | undefined;
    /** Users can override the default CryptoProviderFactory with this property. This factory will be used for creating signature providers. */
    cryptoProviderFactory?: CryptoProviderFactory | undefined;
    /** Gets the SecurityKey used for signature creation or validation. */
    key?: SecurityKey | undefined;
    /** Gets the key id associated with SecurityKey. */
    kid?: string | undefined;
}

/** Initializes a new instance of JwtPayload which contains JSON objects representing the claims contained in the JWT. Each claim is a JSON object of the form { Name, Value }. */
export class JwtPayload implements IJwtPayload {
    /** Gets the 'value' of the 'actor' claim { actort, 'value' }. */
    actort?: string | undefined;
    /** Gets the 'value' of the 'acr' claim { acr, 'value' }. */
    acr?: string | undefined;
    /** Gets the 'value' of the 'amr' claim { amr, 'value' } as list of strings. */
    amr?: string[] | undefined;
    /** Gets the 'value' of the 'auth_time' claim { auth_time, 'value' }. */
    authTime?: number | undefined;
    /** Gets the 'value' of the 'audience' claim { aud, 'value' } as a list of strings. */
    aud?: string[] | undefined;
    /** Gets the 'value' of the 'azp' claim { azp, 'value' }. */
    azp?: string | undefined;
    /** Gets 'value' of the 'c_hash' claim { c_hash, 'value' }. */
    cHash?: string | undefined;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' }. */
    exp?: number | undefined;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' }. */
    expiration?: number | undefined;
    /** Gets the 'value' of the 'JWT ID' claim { jti, 'value' }. */
    jti?: string | undefined;
    /** Gets the 'value' of the 'Issued At' claim { iat, 'value' }. */
    iat?: number | undefined;
    /** Gets the 'value' of the 'issuer' claim { iss, 'value' }. */
    iss?: string | undefined;
    /** Gets the 'value' of the 'expiration' claim { nbf, 'value' }. */
    nbf?: number | undefined;
    /** Gets the 'value' of the 'nonce' claim { nonce, 'value' }. */
    nonce?: string | undefined;
    /** Gets the 'value' of the 'notebefore' claim { nbf, 'value' }. */
    notBefore?: number | undefined;
    /** Gets the 'value' of the 'subject' claim { sub, 'value' }. */
    sub?: string | undefined;
    /** Gets the 'value' of the 'notbefore' claim { nbf, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    validFrom?: Date;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    validTo?: Date;
    /** Gets the 'value' of the 'issued at' claim { iat, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    issuedAt?: Date;
    /** Gets a IEnumerable`1Claim for each JSON { name, value }. */
    claims?: Claim[] | undefined;

    [key: string]: any;

    constructor(data?: IJwtPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.actort = _data["actort"];
            this.acr = _data["acr"];
            if (Array.isArray(_data["amr"])) {
                this.amr = [] as any;
                for (let item of _data["amr"])
                    this.amr!.push(item);
            }
            this.authTime = _data["authTime"];
            if (Array.isArray(_data["aud"])) {
                this.aud = [] as any;
                for (let item of _data["aud"])
                    this.aud!.push(item);
            }
            this.azp = _data["azp"];
            this.cHash = _data["cHash"];
            this.exp = _data["exp"];
            this.expiration = _data["expiration"];
            this.jti = _data["jti"];
            this.iat = _data["iat"];
            this.iss = _data["iss"];
            this.nbf = _data["nbf"];
            this.nonce = _data["nonce"];
            this.notBefore = _data["notBefore"];
            this.sub = _data["sub"];
            this.validFrom = _data["validFrom"] ? new Date(_data["validFrom"].toString()) : undefined as any;
            this.validTo = _data["validTo"] ? new Date(_data["validTo"].toString()) : undefined as any;
            this.issuedAt = _data["issuedAt"] ? new Date(_data["issuedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JwtPayload {
        data = typeof data === 'object' ? data : {};
        let result = new JwtPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["actort"] = this.actort;
        data["acr"] = this.acr;
        if (Array.isArray(this.amr)) {
            data["amr"] = [];
            for (let item of this.amr)
                data["amr"].push(item);
        }
        data["authTime"] = this.authTime;
        if (Array.isArray(this.aud)) {
            data["aud"] = [];
            for (let item of this.aud)
                data["aud"].push(item);
        }
        data["azp"] = this.azp;
        data["cHash"] = this.cHash;
        data["exp"] = this.exp;
        data["expiration"] = this.expiration;
        data["jti"] = this.jti;
        data["iat"] = this.iat;
        data["iss"] = this.iss;
        data["nbf"] = this.nbf;
        data["nonce"] = this.nonce;
        data["notBefore"] = this.notBefore;
        data["sub"] = this.sub;
        data["validFrom"] = this.validFrom ? this.validFrom.toISOString() : undefined as any;
        data["validTo"] = this.validTo ? this.validTo.toISOString() : undefined as any;
        data["issuedAt"] = this.issuedAt ? this.issuedAt.toISOString() : undefined as any;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

/** Initializes a new instance of JwtPayload which contains JSON objects representing the claims contained in the JWT. Each claim is a JSON object of the form { Name, Value }. */
export interface IJwtPayload {
    /** Gets the 'value' of the 'actor' claim { actort, 'value' }. */
    actort?: string | undefined;
    /** Gets the 'value' of the 'acr' claim { acr, 'value' }. */
    acr?: string | undefined;
    /** Gets the 'value' of the 'amr' claim { amr, 'value' } as list of strings. */
    amr?: string[] | undefined;
    /** Gets the 'value' of the 'auth_time' claim { auth_time, 'value' }. */
    authTime?: number | undefined;
    /** Gets the 'value' of the 'audience' claim { aud, 'value' } as a list of strings. */
    aud?: string[] | undefined;
    /** Gets the 'value' of the 'azp' claim { azp, 'value' }. */
    azp?: string | undefined;
    /** Gets 'value' of the 'c_hash' claim { c_hash, 'value' }. */
    cHash?: string | undefined;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' }. */
    exp?: number | undefined;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' }. */
    expiration?: number | undefined;
    /** Gets the 'value' of the 'JWT ID' claim { jti, 'value' }. */
    jti?: string | undefined;
    /** Gets the 'value' of the 'Issued At' claim { iat, 'value' }. */
    iat?: number | undefined;
    /** Gets the 'value' of the 'issuer' claim { iss, 'value' }. */
    iss?: string | undefined;
    /** Gets the 'value' of the 'expiration' claim { nbf, 'value' }. */
    nbf?: number | undefined;
    /** Gets the 'value' of the 'nonce' claim { nonce, 'value' }. */
    nonce?: string | undefined;
    /** Gets the 'value' of the 'notebefore' claim { nbf, 'value' }. */
    notBefore?: number | undefined;
    /** Gets the 'value' of the 'subject' claim { sub, 'value' }. */
    sub?: string | undefined;
    /** Gets the 'value' of the 'notbefore' claim { nbf, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    validFrom?: Date;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    validTo?: Date;
    /** Gets the 'value' of the 'issued at' claim { iat, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    issuedAt?: Date;
    /** Gets a IEnumerable`1Claim for each JSON { name, value }. */
    claims?: Claim[] | undefined;

    [key: string]: any;
}

export class Claim implements IClaim {
    customSerializationData?: string | undefined;
    issuer?: string;
    originalIssuer?: string;
    properties?: { [key: string]: string; };
    subject?: ClaimsIdentity | undefined;
    type?: string;
    value?: string;
    valueType?: string;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customSerializationData = _data["customSerializationData"];
            this.issuer = _data["issuer"];
            this.originalIssuer = _data["originalIssuer"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (this.properties as any)![key] = _data["properties"][key];
                }
            }
            this.subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : undefined as any;
            this.type = _data["type"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customSerializationData"] = this.customSerializationData;
        data["issuer"] = this.issuer;
        data["originalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (data["properties"] as any)[key] = (this.properties as any)[key];
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : undefined as any;
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data;
    }
}

export interface IClaim {
    customSerializationData?: string | undefined;
    issuer?: string;
    originalIssuer?: string;
    properties?: { [key: string]: string; };
    subject?: ClaimsIdentity | undefined;
    type?: string;
    value?: string;
    valueType?: string;
}

export class ClaimsIdentity implements IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[];
    customSerializationData?: string | undefined;
    externalClaims?: Claim[][];
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string;
    roleClaimType?: string;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationType = _data["authenticationType"];
            this.isAuthenticated = _data["isAuthenticated"];
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : undefined as any;
            this.bootstrapContext = _data["bootstrapContext"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            this.customSerializationData = _data["customSerializationData"];
            if (Array.isArray(_data["externalClaims"])) {
                this.externalClaims = [] as any;
                for (let item of _data["externalClaims"])
                    this.externalClaims!.push(item);
            }
            this.label = _data["label"];
            this.name = _data["name"];
            this.nameClaimType = _data["nameClaimType"];
            this.roleClaimType = _data["roleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        data["actor"] = this.actor ? this.actor.toJSON() : undefined as any;
        data["bootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item ? item.toJSON() : undefined as any);
        }
        data["customSerializationData"] = this.customSerializationData;
        if (Array.isArray(this.externalClaims)) {
            data["externalClaims"] = [];
            for (let item of this.externalClaims)
                data["externalClaims"].push(item);
        }
        data["label"] = this.label;
        data["name"] = this.name;
        data["nameClaimType"] = this.nameClaimType;
        data["roleClaimType"] = this.roleClaimType;
        return data;
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[];
    customSerializationData?: string | undefined;
    externalClaims?: Claim[][];
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string;
    roleClaimType?: string;
}

export class DecodeJwtRequest implements IDecodeJwtRequest {
    secretKey?: string;
    audience?: string;
    issuer?: string;
    encodedToken?: string;

    constructor(data?: IDecodeJwtRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.secretKey = _data["secretKey"];
            this.audience = _data["audience"];
            this.issuer = _data["issuer"];
            this.encodedToken = _data["encodedToken"];
        }
    }

    static fromJS(data: any): DecodeJwtRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DecodeJwtRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secretKey"] = this.secretKey;
        data["audience"] = this.audience;
        data["issuer"] = this.issuer;
        data["encodedToken"] = this.encodedToken;
        return data;
    }
}

export interface IDecodeJwtRequest {
    secretKey?: string;
    audience?: string;
    issuer?: string;
    encodedToken?: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}