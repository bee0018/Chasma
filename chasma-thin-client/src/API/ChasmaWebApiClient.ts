//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class HealthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:44349";
    }

    getHeartbeat(): Promise<HeartbeatMessage> {
        let url_ = this.baseUrl + "/api/Health/heartbeat";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHeartbeat(_response);
        });
    }

    protected processGetHeartbeat(response: Response): Promise<HeartbeatMessage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HeartbeatMessage.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HeartbeatMessage>(null as any);
    }
}

export class JwtClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:44349";
    }

    encodeJwt(encodeJwtRequest: EncodeJwtRequest): Promise<EncodeJwtResponse> {
        let url_ = this.baseUrl + "/api/encodeJwt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(encodeJwtRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEncodeJwt(_response);
        });
    }

    protected processEncodeJwt(response: Response): Promise<EncodeJwtResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EncodeJwtResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EncodeJwtResponse>(null as any);
    }

    decodeJwt(decodeJwtRequest: DecodeJwtRequest): Promise<DecodeJwtResponse> {
        let url_ = this.baseUrl + "/api/decodeJwt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(decodeJwtRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDecodeJwt(_response);
        });
    }

    protected processDecodeJwt(response: Response): Promise<DecodeJwtResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DecodeJwtResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DecodeJwtResponse>(null as any);
    }
}

export class RepositoryConfigurationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:44349";
    }

    getLocalGitRepositories(userId: number | undefined): Promise<LocalRepositoriesInfoMessage> {
        let url_ = this.baseUrl + "/api/RepositoryConfiguration/getLocalGitRepositories?";
        if (userId === null)
            throw new globalThis.Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLocalGitRepositories(_response);
        });
    }

    protected processGetLocalGitRepositories(response: Response): Promise<LocalRepositoriesInfoMessage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocalRepositoriesInfoMessage.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LocalRepositoriesInfoMessage>(null as any);
    }

    addLocalGitRepositories(userId: number | undefined): Promise<AddLocalRepositoriesResponse> {
        let url_ = this.baseUrl + "/api/RepositoryConfiguration/addLocalGitRepositories?";
        if (userId === null)
            throw new globalThis.Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddLocalGitRepositories(_response);
        });
    }

    protected processAddLocalGitRepositories(response: Response): Promise<AddLocalRepositoriesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddLocalRepositoriesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AddLocalRepositoriesResponse>(null as any);
    }

    deleteRepository(request: DeleteRepositoryRequest): Promise<DeleteRepositoryResponse> {
        let url_ = this.baseUrl + "/api/RepositoryConfiguration/deleteRepository";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRepository(_response);
        });
    }

    protected processDeleteRepository(response: Response): Promise<DeleteRepositoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteRepositoryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeleteRepositoryResponse>(null as any);
    }
}

export class RepositoryStatusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:44349";
    }

    getChasmaWorkflowResults(request: GetWorkflowResultsRequest): Promise<GitHubWorkflowRunResponse> {
        let url_ = this.baseUrl + "/api/RepositoryStatus/workflowRuns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetChasmaWorkflowResults(_response);
        });
    }

    protected processGetChasmaWorkflowResults(response: Response): Promise<GitHubWorkflowRunResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GitHubWorkflowRunResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GitHubWorkflowRunResponse>(null as any);
    }

    getRepoStatus(gitStatusRequest: GitStatusRequest): Promise<GitStatusResponse> {
        let url_ = this.baseUrl + "/api/RepositoryStatus/gitStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(gitStatusRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRepoStatus(_response);
        });
    }

    protected processGetRepoStatus(response: Response): Promise<GitStatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GitStatusResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GitStatusResponse>(null as any);
    }

    applyStagingAction(applyStagingActionRequest: ApplyStagingActionRequest): Promise<ApplyStagingActionResponse> {
        let url_ = this.baseUrl + "/api/RepositoryStatus/applyStagingAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(applyStagingActionRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplyStagingAction(_response);
        });
    }

    protected processApplyStagingAction(response: Response): Promise<ApplyStagingActionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplyStagingActionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplyStagingActionResponse>(null as any);
    }
}

export class UserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:44349";
    }

    getUserAcccounts(): Promise<UserAccountModel[]> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserAcccounts(_response);
        });
    }

    protected processGetUserAcccounts(response: Response): Promise<UserAccountModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserAccountModel.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserAccountModel[]>(null as any);
    }

    login(request: LoginRequest): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/api/User/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    addUserAccount(request: AddUserRequest): Promise<AddUserResponse> {
        let url_ = this.baseUrl + "/api/User/addUserAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddUserAccount(_response);
        });
    }

    protected processAddUserAccount(response: Response): Promise<AddUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddUserResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AddUserResponse>(null as any);
    }
}

export class UuidClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:44349";
    }

    generateUuid(): Promise<string> {
        let url_ = this.baseUrl + "/api/uuid";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateUuid(_response);
        });
    }

    protected processGenerateUuid(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class ChasmaXmlBase implements IChasmaXmlBase {

    constructor(data?: IChasmaXmlBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ChasmaXmlBase {
        data = typeof data === 'object' ? data : {};
        let result = new ChasmaXmlBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IChasmaXmlBase {
}

export class HeartbeatMessage extends ChasmaXmlBase implements IHeartbeatMessage {
    message?: string;
    status?: HeartbeatStatus;

    constructor(data?: IHeartbeatMessage) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.message = _data["message"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): HeartbeatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new HeartbeatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["status"] = this.status;
        super.toJSON(data);
        return data;
    }
}

export interface IHeartbeatMessage extends IChasmaXmlBase {
    message?: string;
    status?: HeartbeatStatus;
}

export enum HeartbeatStatus {
    Ok = 0,
    Error = 1,
}

export class ResponseBase extends ChasmaXmlBase implements IResponseBase {
    isErrorResponse?: boolean;
    errorMessage?: string | undefined;

    constructor(data?: IResponseBase) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isErrorResponse = _data["isErrorResponse"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): ResponseBase {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isErrorResponse"] = this.isErrorResponse;
        data["errorMessage"] = this.errorMessage;
        super.toJSON(data);
        return data;
    }
}

export interface IResponseBase extends IChasmaXmlBase {
    isErrorResponse?: boolean;
    errorMessage?: string | undefined;
}

export class EncodeJwtResponse extends ResponseBase implements IEncodeJwtResponse {
    token?: string;
    expirationTime?: Date;

    constructor(data?: IEncodeJwtResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.token = _data["token"];
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): EncodeJwtResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EncodeJwtResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : undefined as any;
        super.toJSON(data);
        return data;
    }
}

export interface IEncodeJwtResponse extends IResponseBase {
    token?: string;
    expirationTime?: Date;
}

export class EncodeJwtRequest implements IEncodeJwtRequest {
    secretKey?: string;
    username?: string;
    name?: string;
    role?: string;
    audience?: string;
    issuer?: string;
    customClaimTypes?: string[];
    customClaimValues?: string[];
    expireInMinutes?: number;

    constructor(data?: IEncodeJwtRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.secretKey = _data["secretKey"];
            this.username = _data["username"];
            this.name = _data["name"];
            this.role = _data["role"];
            this.audience = _data["audience"];
            this.issuer = _data["issuer"];
            if (Array.isArray(_data["customClaimTypes"])) {
                this.customClaimTypes = [] as any;
                for (let item of _data["customClaimTypes"])
                    this.customClaimTypes!.push(item);
            }
            if (Array.isArray(_data["customClaimValues"])) {
                this.customClaimValues = [] as any;
                for (let item of _data["customClaimValues"])
                    this.customClaimValues!.push(item);
            }
            this.expireInMinutes = _data["expireInMinutes"];
        }
    }

    static fromJS(data: any): EncodeJwtRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EncodeJwtRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secretKey"] = this.secretKey;
        data["username"] = this.username;
        data["name"] = this.name;
        data["role"] = this.role;
        data["audience"] = this.audience;
        data["issuer"] = this.issuer;
        if (Array.isArray(this.customClaimTypes)) {
            data["customClaimTypes"] = [];
            for (let item of this.customClaimTypes)
                data["customClaimTypes"].push(item);
        }
        if (Array.isArray(this.customClaimValues)) {
            data["customClaimValues"] = [];
            for (let item of this.customClaimValues)
                data["customClaimValues"].push(item);
        }
        data["expireInMinutes"] = this.expireInMinutes;
        return data;
    }
}

export interface IEncodeJwtRequest {
    secretKey?: string;
    username?: string;
    name?: string;
    role?: string;
    audience?: string;
    issuer?: string;
    customClaimTypes?: string[];
    customClaimValues?: string[];
    expireInMinutes?: number;
}

export class DecodeJwtResponse extends ResponseBase implements IDecodeJwtResponse {
    decodedJwtTokenString?: string;
    isValidToken?: boolean;
    header?: JwtHeader;
    payload?: JwtPayload;
    claimTypes?: string[];
    claimValues?: string[];

    constructor(data?: IDecodeJwtResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.decodedJwtTokenString = _data["decodedJwtTokenString"];
            this.isValidToken = _data["isValidToken"];
            this.header = _data["header"] ? JwtHeader.fromJS(_data["header"]) : undefined as any;
            this.payload = _data["payload"] ? JwtPayload.fromJS(_data["payload"]) : undefined as any;
            if (Array.isArray(_data["claimTypes"])) {
                this.claimTypes = [] as any;
                for (let item of _data["claimTypes"])
                    this.claimTypes!.push(item);
            }
            if (Array.isArray(_data["claimValues"])) {
                this.claimValues = [] as any;
                for (let item of _data["claimValues"])
                    this.claimValues!.push(item);
            }
        }
    }

    static fromJS(data: any): DecodeJwtResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DecodeJwtResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["decodedJwtTokenString"] = this.decodedJwtTokenString;
        data["isValidToken"] = this.isValidToken;
        data["header"] = this.header ? this.header.toJSON() : undefined as any;
        data["payload"] = this.payload ? this.payload.toJSON() : undefined as any;
        if (Array.isArray(this.claimTypes)) {
            data["claimTypes"] = [];
            for (let item of this.claimTypes)
                data["claimTypes"].push(item);
        }
        if (Array.isArray(this.claimValues)) {
            data["claimValues"] = [];
            for (let item of this.claimValues)
                data["claimValues"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDecodeJwtResponse extends IResponseBase {
    decodedJwtTokenString?: string;
    isValidToken?: boolean;
    header?: JwtHeader;
    payload?: JwtPayload;
    claimTypes?: string[];
    claimValues?: string[];
}

/** Initializes a new instance of JwtHeader which contains JSON objects representing the cryptographic operations applied to the JWT and optionally any additional properties of the JWT. The member names within the JWT Header are referred to as Header Parameter Names. These names MUST be unique and the values must be String(s). The corresponding values are referred to as Header Parameter Values. */
export class JwtHeader implements IJwtHeader {
    /** Gets the signature algorithm that was used to create the signature. */
    alg?: string | undefined;
    /** Gets the content mime type (Cty) of the token. */
    cty?: string | undefined;
    /** Gets the encryption algorithm (Enc) of the token. */
    enc?: string | undefined;
    /** Gets the EncryptingCredentials passed in the constructor. */
    encryptingCredentials?: EncryptingCredentials | undefined;
    /** Gets the iv of symmetric key wrap. */
    iv?: string | undefined;
    /** Gets the key identifier for the security key used to sign the token */
    kid?: string | undefined;
    /** Gets the SigningCredentials passed in the constructor. */
    signingCredentials?: SigningCredentials | undefined;
    /** Gets the mime type (Typ) of the token. */
    typ?: string | undefined;
    /** Gets the thumbprint of the certificate used to sign the token */
    x5t?: string | undefined;
    /** Gets the certificate used to sign the token */
    x5c?: string | undefined;
    /** Gets the 'value' of the 'zip' claim { zip, 'value' }. */
    zip?: string | undefined;

    [key: string]: any;

    constructor(data?: IJwtHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.alg = _data["alg"];
            this.cty = _data["cty"];
            this.enc = _data["enc"];
            this.encryptingCredentials = _data["encryptingCredentials"] ? EncryptingCredentials.fromJS(_data["encryptingCredentials"]) : undefined as any;
            this.iv = _data["iv"];
            this.kid = _data["kid"];
            this.signingCredentials = _data["signingCredentials"] ? SigningCredentials.fromJS(_data["signingCredentials"]) : undefined as any;
            this.typ = _data["typ"];
            this.x5t = _data["x5t"];
            this.x5c = _data["x5c"];
            this.zip = _data["zip"];
        }
    }

    static fromJS(data: any): JwtHeader {
        data = typeof data === 'object' ? data : {};
        let result = new JwtHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["alg"] = this.alg;
        data["cty"] = this.cty;
        data["enc"] = this.enc;
        data["encryptingCredentials"] = this.encryptingCredentials ? this.encryptingCredentials.toJSON() : undefined as any;
        data["iv"] = this.iv;
        data["kid"] = this.kid;
        data["signingCredentials"] = this.signingCredentials ? this.signingCredentials.toJSON() : undefined as any;
        data["typ"] = this.typ;
        data["x5t"] = this.x5t;
        data["x5c"] = this.x5c;
        data["zip"] = this.zip;
        return data;
    }
}

/** Initializes a new instance of JwtHeader which contains JSON objects representing the cryptographic operations applied to the JWT and optionally any additional properties of the JWT. The member names within the JWT Header are referred to as Header Parameter Names. These names MUST be unique and the values must be String(s). The corresponding values are referred to as Header Parameter Values. */
export interface IJwtHeader {
    /** Gets the signature algorithm that was used to create the signature. */
    alg?: string | undefined;
    /** Gets the content mime type (Cty) of the token. */
    cty?: string | undefined;
    /** Gets the encryption algorithm (Enc) of the token. */
    enc?: string | undefined;
    /** Gets the EncryptingCredentials passed in the constructor. */
    encryptingCredentials?: EncryptingCredentials | undefined;
    /** Gets the iv of symmetric key wrap. */
    iv?: string | undefined;
    /** Gets the key identifier for the security key used to sign the token */
    kid?: string | undefined;
    /** Gets the SigningCredentials passed in the constructor. */
    signingCredentials?: SigningCredentials | undefined;
    /** Gets the mime type (Typ) of the token. */
    typ?: string | undefined;
    /** Gets the thumbprint of the certificate used to sign the token */
    x5t?: string | undefined;
    /** Gets the certificate used to sign the token */
    x5c?: string | undefined;
    /** Gets the 'value' of the 'zip' claim { zip, 'value' }. */
    zip?: string | undefined;

    [key: string]: any;
}

/** A class for properties that are used for token encryption. */
export class EncryptingCredentials implements IEncryptingCredentials {
    /** Gets the key wrap algorithm used for session key encryption. */
    alg?: string | undefined;
    /** Gets the data encryption algorithm. */
    enc?: string | undefined;
    /** Gets or sets the public key used in Key Agreement Algorithms. */
    keyExchangePublicKey?: SecurityKey | undefined;
    /** Users can override the default CryptoProviderFactory with this property. This factory will be used for creating encryption providers. */
    cryptoProviderFactory?: CryptoProviderFactory | undefined;
    /** Gets or sets a bool that controls if the encrypted token creation will set default 'cty' if not specified. */
    setDefaultCtyClaim?: boolean;
    /** Gets the SecurityKey used for encryption. */
    key?: SecurityKey | undefined;

    constructor(data?: IEncryptingCredentials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alg = _data["alg"];
            this.enc = _data["enc"];
            this.keyExchangePublicKey = _data["keyExchangePublicKey"] ? SecurityKey.fromJS(_data["keyExchangePublicKey"]) : undefined as any;
            this.cryptoProviderFactory = _data["cryptoProviderFactory"] ? CryptoProviderFactory.fromJS(_data["cryptoProviderFactory"]) : undefined as any;
            this.setDefaultCtyClaim = _data["setDefaultCtyClaim"];
            this.key = _data["key"] ? SecurityKey.fromJS(_data["key"]) : undefined as any;
        }
    }

    static fromJS(data: any): EncryptingCredentials {
        data = typeof data === 'object' ? data : {};
        let result = new EncryptingCredentials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alg"] = this.alg;
        data["enc"] = this.enc;
        data["keyExchangePublicKey"] = this.keyExchangePublicKey ? this.keyExchangePublicKey.toJSON() : undefined as any;
        data["cryptoProviderFactory"] = this.cryptoProviderFactory ? this.cryptoProviderFactory.toJSON() : undefined as any;
        data["setDefaultCtyClaim"] = this.setDefaultCtyClaim;
        data["key"] = this.key ? this.key.toJSON() : undefined as any;
        return data;
    }
}

/** A class for properties that are used for token encryption. */
export interface IEncryptingCredentials {
    /** Gets the key wrap algorithm used for session key encryption. */
    alg?: string | undefined;
    /** Gets the data encryption algorithm. */
    enc?: string | undefined;
    /** Gets or sets the public key used in Key Agreement Algorithms. */
    keyExchangePublicKey?: SecurityKey | undefined;
    /** Users can override the default CryptoProviderFactory with this property. This factory will be used for creating encryption providers. */
    cryptoProviderFactory?: CryptoProviderFactory | undefined;
    /** Gets or sets a bool that controls if the encrypted token creation will set default 'cty' if not specified. */
    setDefaultCtyClaim?: boolean;
    /** Gets the SecurityKey used for encryption. */
    key?: SecurityKey | undefined;
}

/** Base class for Security Key. */
export abstract class SecurityKey implements ISecurityKey {
    /** This must be overridden to get the size of this SecurityKey. */
    keySize?: number;

    constructor(data?: ISecurityKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keySize = _data["keySize"];
        }
    }

    static fromJS(data: any): SecurityKey {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SecurityKey' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keySize"] = this.keySize;
        return data;
    }
}

/** Base class for Security Key. */
export interface ISecurityKey {
    /** This must be overridden to get the size of this SecurityKey. */
    keySize?: number;
}

/** Creates cryptographic operators by specifying a SecurityKey's and algorithms. */
export class CryptoProviderFactory implements ICryptoProviderFactory {
    /** Gets the CryptoProviderCache. */
    cryptoProviderCache?: CryptoProviderCache | undefined;
    /** Extensibility point for creating custom cryptographic operators. */
    customCryptoProvider?: ICryptoProvider | undefined;
    /** Gets or sets a bool controlling if SignatureProvider should be cached. */
    cacheSignatureProviders?: boolean;
    /** Gets or sets the maximum size of the object pool used by the SignatureProvider that are used for crypto objects. */
    signatureProviderObjectPoolCacheSize?: number;

    constructor(data?: ICryptoProviderFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.cacheSignatureProviders = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cryptoProviderCache = _data["cryptoProviderCache"] ? CryptoProviderCache.fromJS(_data["cryptoProviderCache"]) : undefined as any;
            this.customCryptoProvider = _data["customCryptoProvider"] ? ICryptoProvider.fromJS(_data["customCryptoProvider"]) : undefined as any;
            this.cacheSignatureProviders = _data["cacheSignatureProviders"] !== undefined ? _data["cacheSignatureProviders"] : true;
            this.signatureProviderObjectPoolCacheSize = _data["signatureProviderObjectPoolCacheSize"];
        }
    }

    static fromJS(data: any): CryptoProviderFactory {
        data = typeof data === 'object' ? data : {};
        let result = new CryptoProviderFactory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cryptoProviderCache"] = this.cryptoProviderCache ? this.cryptoProviderCache.toJSON() : undefined as any;
        data["customCryptoProvider"] = this.customCryptoProvider ? this.customCryptoProvider.toJSON() : undefined as any;
        data["cacheSignatureProviders"] = this.cacheSignatureProviders;
        data["signatureProviderObjectPoolCacheSize"] = this.signatureProviderObjectPoolCacheSize;
        return data;
    }
}

/** Creates cryptographic operators by specifying a SecurityKey's and algorithms. */
export interface ICryptoProviderFactory {
    /** Gets the CryptoProviderCache. */
    cryptoProviderCache?: CryptoProviderCache | undefined;
    /** Extensibility point for creating custom cryptographic operators. */
    customCryptoProvider?: ICryptoProvider | undefined;
    /** Gets or sets a bool controlling if SignatureProvider should be cached. */
    cacheSignatureProviders?: boolean;
    /** Gets or sets the maximum size of the object pool used by the SignatureProvider that are used for crypto objects. */
    signatureProviderObjectPoolCacheSize?: number;
}

/** Abstract definition of a cache for cryptographic providers. */
export abstract class CryptoProviderCache implements ICryptoProviderCache {

    constructor(data?: ICryptoProviderCache) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CryptoProviderCache {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CryptoProviderCache' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Abstract definition of a cache for cryptographic providers. */
export interface ICryptoProviderCache {
}

/** Provides extensibility for cryptographic operators. If custom operators are needed, CustomCryptoProvider can be set to return these operators. This property will be checked before each creation. */
export abstract class ICryptoProvider implements IICryptoProvider {

    constructor(data?: IICryptoProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICryptoProvider {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ICryptoProvider' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Provides extensibility for cryptographic operators. If custom operators are needed, CustomCryptoProvider can be set to return these operators. This property will be checked before each creation. */
export interface IICryptoProvider {
}

/** Defines the SecurityKey, algorithm and digest for digital signatures. */
export class SigningCredentials implements ISigningCredentials {
    /** Gets the signature algorithm. */
    algorithm?: string | undefined;
    /** Gets the digest algorithm. */
    digest?: string | undefined;
    /** Users can override the default CryptoProviderFactory with this property. This factory will be used for creating signature providers. */
    cryptoProviderFactory?: CryptoProviderFactory | undefined;
    /** Gets the SecurityKey used for signature creation or validation. */
    key?: SecurityKey | undefined;
    /** Gets the key id associated with SecurityKey. */
    kid?: string | undefined;

    constructor(data?: ISigningCredentials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.algorithm = _data["algorithm"];
            this.digest = _data["digest"];
            this.cryptoProviderFactory = _data["cryptoProviderFactory"] ? CryptoProviderFactory.fromJS(_data["cryptoProviderFactory"]) : undefined as any;
            this.key = _data["key"] ? SecurityKey.fromJS(_data["key"]) : undefined as any;
            this.kid = _data["kid"];
        }
    }

    static fromJS(data: any): SigningCredentials {
        data = typeof data === 'object' ? data : {};
        let result = new SigningCredentials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["algorithm"] = this.algorithm;
        data["digest"] = this.digest;
        data["cryptoProviderFactory"] = this.cryptoProviderFactory ? this.cryptoProviderFactory.toJSON() : undefined as any;
        data["key"] = this.key ? this.key.toJSON() : undefined as any;
        data["kid"] = this.kid;
        return data;
    }
}

/** Defines the SecurityKey, algorithm and digest for digital signatures. */
export interface ISigningCredentials {
    /** Gets the signature algorithm. */
    algorithm?: string | undefined;
    /** Gets the digest algorithm. */
    digest?: string | undefined;
    /** Users can override the default CryptoProviderFactory with this property. This factory will be used for creating signature providers. */
    cryptoProviderFactory?: CryptoProviderFactory | undefined;
    /** Gets the SecurityKey used for signature creation or validation. */
    key?: SecurityKey | undefined;
    /** Gets the key id associated with SecurityKey. */
    kid?: string | undefined;
}

/** Initializes a new instance of JwtPayload which contains JSON objects representing the claims contained in the JWT. Each claim is a JSON object of the form { Name, Value }. */
export class JwtPayload implements IJwtPayload {
    /** Gets the 'value' of the 'actor' claim { actort, 'value' }. */
    actort?: string | undefined;
    /** Gets the 'value' of the 'acr' claim { acr, 'value' }. */
    acr?: string | undefined;
    /** Gets the 'value' of the 'amr' claim { amr, 'value' } as list of strings. */
    amr?: string[] | undefined;
    /** Gets the 'value' of the 'auth_time' claim { auth_time, 'value' }. */
    authTime?: number | undefined;
    /** Gets the 'value' of the 'audience' claim { aud, 'value' } as a list of strings. */
    aud?: string[] | undefined;
    /** Gets the 'value' of the 'azp' claim { azp, 'value' }. */
    azp?: string | undefined;
    /** Gets 'value' of the 'c_hash' claim { c_hash, 'value' }. */
    cHash?: string | undefined;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' }. */
    exp?: number | undefined;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' }. */
    expiration?: number | undefined;
    /** Gets the 'value' of the 'JWT ID' claim { jti, 'value' }. */
    jti?: string | undefined;
    /** Gets the 'value' of the 'Issued At' claim { iat, 'value' }. */
    iat?: number | undefined;
    /** Gets the 'value' of the 'issuer' claim { iss, 'value' }. */
    iss?: string | undefined;
    /** Gets the 'value' of the 'expiration' claim { nbf, 'value' }. */
    nbf?: number | undefined;
    /** Gets the 'value' of the 'nonce' claim { nonce, 'value' }. */
    nonce?: string | undefined;
    /** Gets the 'value' of the 'notebefore' claim { nbf, 'value' }. */
    notBefore?: number | undefined;
    /** Gets the 'value' of the 'subject' claim { sub, 'value' }. */
    sub?: string | undefined;
    /** Gets the 'value' of the 'notbefore' claim { nbf, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    validFrom?: Date;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    validTo?: Date;
    /** Gets the 'value' of the 'issued at' claim { iat, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    issuedAt?: Date;
    /** Gets a IEnumerable`1Claim for each JSON { name, value }. */
    claims?: Claim[] | undefined;

    [key: string]: any;

    constructor(data?: IJwtPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.actort = _data["actort"];
            this.acr = _data["acr"];
            if (Array.isArray(_data["amr"])) {
                this.amr = [] as any;
                for (let item of _data["amr"])
                    this.amr!.push(item);
            }
            this.authTime = _data["authTime"];
            if (Array.isArray(_data["aud"])) {
                this.aud = [] as any;
                for (let item of _data["aud"])
                    this.aud!.push(item);
            }
            this.azp = _data["azp"];
            this.cHash = _data["cHash"];
            this.exp = _data["exp"];
            this.expiration = _data["expiration"];
            this.jti = _data["jti"];
            this.iat = _data["iat"];
            this.iss = _data["iss"];
            this.nbf = _data["nbf"];
            this.nonce = _data["nonce"];
            this.notBefore = _data["notBefore"];
            this.sub = _data["sub"];
            this.validFrom = _data["validFrom"] ? new Date(_data["validFrom"].toString()) : undefined as any;
            this.validTo = _data["validTo"] ? new Date(_data["validTo"].toString()) : undefined as any;
            this.issuedAt = _data["issuedAt"] ? new Date(_data["issuedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JwtPayload {
        data = typeof data === 'object' ? data : {};
        let result = new JwtPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["actort"] = this.actort;
        data["acr"] = this.acr;
        if (Array.isArray(this.amr)) {
            data["amr"] = [];
            for (let item of this.amr)
                data["amr"].push(item);
        }
        data["authTime"] = this.authTime;
        if (Array.isArray(this.aud)) {
            data["aud"] = [];
            for (let item of this.aud)
                data["aud"].push(item);
        }
        data["azp"] = this.azp;
        data["cHash"] = this.cHash;
        data["exp"] = this.exp;
        data["expiration"] = this.expiration;
        data["jti"] = this.jti;
        data["iat"] = this.iat;
        data["iss"] = this.iss;
        data["nbf"] = this.nbf;
        data["nonce"] = this.nonce;
        data["notBefore"] = this.notBefore;
        data["sub"] = this.sub;
        data["validFrom"] = this.validFrom ? this.validFrom.toISOString() : undefined as any;
        data["validTo"] = this.validTo ? this.validTo.toISOString() : undefined as any;
        data["issuedAt"] = this.issuedAt ? this.issuedAt.toISOString() : undefined as any;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

/** Initializes a new instance of JwtPayload which contains JSON objects representing the claims contained in the JWT. Each claim is a JSON object of the form { Name, Value }. */
export interface IJwtPayload {
    /** Gets the 'value' of the 'actor' claim { actort, 'value' }. */
    actort?: string | undefined;
    /** Gets the 'value' of the 'acr' claim { acr, 'value' }. */
    acr?: string | undefined;
    /** Gets the 'value' of the 'amr' claim { amr, 'value' } as list of strings. */
    amr?: string[] | undefined;
    /** Gets the 'value' of the 'auth_time' claim { auth_time, 'value' }. */
    authTime?: number | undefined;
    /** Gets the 'value' of the 'audience' claim { aud, 'value' } as a list of strings. */
    aud?: string[] | undefined;
    /** Gets the 'value' of the 'azp' claim { azp, 'value' }. */
    azp?: string | undefined;
    /** Gets 'value' of the 'c_hash' claim { c_hash, 'value' }. */
    cHash?: string | undefined;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' }. */
    exp?: number | undefined;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' }. */
    expiration?: number | undefined;
    /** Gets the 'value' of the 'JWT ID' claim { jti, 'value' }. */
    jti?: string | undefined;
    /** Gets the 'value' of the 'Issued At' claim { iat, 'value' }. */
    iat?: number | undefined;
    /** Gets the 'value' of the 'issuer' claim { iss, 'value' }. */
    iss?: string | undefined;
    /** Gets the 'value' of the 'expiration' claim { nbf, 'value' }. */
    nbf?: number | undefined;
    /** Gets the 'value' of the 'nonce' claim { nonce, 'value' }. */
    nonce?: string | undefined;
    /** Gets the 'value' of the 'notebefore' claim { nbf, 'value' }. */
    notBefore?: number | undefined;
    /** Gets the 'value' of the 'subject' claim { sub, 'value' }. */
    sub?: string | undefined;
    /** Gets the 'value' of the 'notbefore' claim { nbf, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    validFrom?: Date;
    /** Gets the 'value' of the 'expiration' claim { exp, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    validTo?: Date;
    /** Gets the 'value' of the 'issued at' claim { iat, 'value' } converted to a DateTime assuming 'value' is seconds since UnixEpoch (UTC 1970-01-01T0:0:0Z). */
    issuedAt?: Date;
    /** Gets a IEnumerable`1Claim for each JSON { name, value }. */
    claims?: Claim[] | undefined;

    [key: string]: any;
}

export class Claim implements IClaim {
    customSerializationData?: string | undefined;
    issuer?: string;
    originalIssuer?: string;
    properties?: { [key: string]: string; };
    subject?: ClaimsIdentity | undefined;
    type?: string;
    value?: string;
    valueType?: string;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customSerializationData = _data["customSerializationData"];
            this.issuer = _data["issuer"];
            this.originalIssuer = _data["originalIssuer"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (this.properties as any)![key] = _data["properties"][key];
                }
            }
            this.subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : undefined as any;
            this.type = _data["type"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customSerializationData"] = this.customSerializationData;
        data["issuer"] = this.issuer;
        data["originalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (data["properties"] as any)[key] = (this.properties as any)[key];
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : undefined as any;
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data;
    }
}

export interface IClaim {
    customSerializationData?: string | undefined;
    issuer?: string;
    originalIssuer?: string;
    properties?: { [key: string]: string; };
    subject?: ClaimsIdentity | undefined;
    type?: string;
    value?: string;
    valueType?: string;
}

export class ClaimsIdentity implements IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[];
    customSerializationData?: string | undefined;
    externalClaims?: Claim[][];
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string;
    roleClaimType?: string;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationType = _data["authenticationType"];
            this.isAuthenticated = _data["isAuthenticated"];
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : undefined as any;
            this.bootstrapContext = _data["bootstrapContext"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            this.customSerializationData = _data["customSerializationData"];
            if (Array.isArray(_data["externalClaims"])) {
                this.externalClaims = [] as any;
                for (let item of _data["externalClaims"])
                    this.externalClaims!.push(item);
            }
            this.label = _data["label"];
            this.name = _data["name"];
            this.nameClaimType = _data["nameClaimType"];
            this.roleClaimType = _data["roleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        data["actor"] = this.actor ? this.actor.toJSON() : undefined as any;
        data["bootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item ? item.toJSON() : undefined as any);
        }
        data["customSerializationData"] = this.customSerializationData;
        if (Array.isArray(this.externalClaims)) {
            data["externalClaims"] = [];
            for (let item of this.externalClaims)
                data["externalClaims"].push(item);
        }
        data["label"] = this.label;
        data["name"] = this.name;
        data["nameClaimType"] = this.nameClaimType;
        data["roleClaimType"] = this.roleClaimType;
        return data;
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[];
    customSerializationData?: string | undefined;
    externalClaims?: Claim[][];
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string;
    roleClaimType?: string;
}

export class DecodeJwtRequest implements IDecodeJwtRequest {
    secretKey?: string;
    audience?: string;
    issuer?: string;
    encodedToken?: string;

    constructor(data?: IDecodeJwtRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.secretKey = _data["secretKey"];
            this.audience = _data["audience"];
            this.issuer = _data["issuer"];
            this.encodedToken = _data["encodedToken"];
        }
    }

    static fromJS(data: any): DecodeJwtRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DecodeJwtRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secretKey"] = this.secretKey;
        data["audience"] = this.audience;
        data["issuer"] = this.issuer;
        data["encodedToken"] = this.encodedToken;
        return data;
    }
}

export interface IDecodeJwtRequest {
    secretKey?: string;
    audience?: string;
    issuer?: string;
    encodedToken?: string;
}

export class LocalRepositoriesInfoMessage extends ChasmaXmlBase implements ILocalRepositoriesInfoMessage {
    timestamp?: string;
    repositories?: LocalGitRepository[];

    constructor(data?: ILocalRepositoriesInfoMessage) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.timestamp = _data["timestamp"];
            if (Array.isArray(_data["repositories"])) {
                this.repositories = [] as any;
                for (let item of _data["repositories"])
                    this.repositories!.push(LocalGitRepository.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalRepositoriesInfoMessage {
        data = typeof data === 'object' ? data : {};
        let result = new LocalRepositoriesInfoMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp;
        if (Array.isArray(this.repositories)) {
            data["repositories"] = [];
            for (let item of this.repositories)
                data["repositories"].push(item ? item.toJSON() : undefined as any);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ILocalRepositoriesInfoMessage extends IChasmaXmlBase {
    timestamp?: string;
    repositories?: LocalGitRepository[];
}

export class LocalGitRepository implements ILocalGitRepository {
    id?: string;
    userId?: number;
    name?: string;
    owner?: string;
    url?: string;

    constructor(data?: ILocalGitRepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.owner = _data["owner"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): LocalGitRepository {
        data = typeof data === 'object' ? data : {};
        let result = new LocalGitRepository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["owner"] = this.owner;
        data["url"] = this.url;
        return data;
    }
}

export interface ILocalGitRepository {
    id?: string;
    userId?: number;
    name?: string;
    owner?: string;
    url?: string;
}

export class AddLocalRepositoriesResponse extends ResponseBase implements IAddLocalRepositoriesResponse {
    currentRepositories?: LocalGitRepository[];

    constructor(data?: IAddLocalRepositoriesResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["currentRepositories"])) {
                this.currentRepositories = [] as any;
                for (let item of _data["currentRepositories"])
                    this.currentRepositories!.push(LocalGitRepository.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddLocalRepositoriesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddLocalRepositoriesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.currentRepositories)) {
            data["currentRepositories"] = [];
            for (let item of this.currentRepositories)
                data["currentRepositories"].push(item ? item.toJSON() : undefined as any);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAddLocalRepositoriesResponse extends IResponseBase {
    currentRepositories?: LocalGitRepository[];
}

export class DeleteRepositoryResponse extends ResponseBase implements IDeleteRepositoryResponse {
    repositories?: LocalGitRepository[];

    constructor(data?: IDeleteRepositoryResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["repositories"])) {
                this.repositories = [] as any;
                for (let item of _data["repositories"])
                    this.repositories!.push(LocalGitRepository.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeleteRepositoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRepositoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.repositories)) {
            data["repositories"] = [];
            for (let item of this.repositories)
                data["repositories"].push(item ? item.toJSON() : undefined as any);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDeleteRepositoryResponse extends IResponseBase {
    repositories?: LocalGitRepository[];
}

export class DeleteRepositoryRequest extends ChasmaXmlBase implements IDeleteRepositoryRequest {
    repositoryId?: string;
    userId?: number;

    constructor(data?: IDeleteRepositoryRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.repositoryId = _data["repositoryId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): DeleteRepositoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRepositoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repositoryId"] = this.repositoryId;
        data["userId"] = this.userId;
        super.toJSON(data);
        return data;
    }
}

export interface IDeleteRepositoryRequest extends IChasmaXmlBase {
    repositoryId?: string;
    userId?: number;
}

export class GitHubWorkflowRunResponse extends ResponseBase implements IGitHubWorkflowRunResponse {
    repositoryName?: string;
    buildCount?: number;
    workflowRunResults?: WorkflowRunResult[];

    constructor(data?: IGitHubWorkflowRunResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.repositoryName = _data["repositoryName"];
            this.buildCount = _data["buildCount"];
            if (Array.isArray(_data["workflowRunResults"])) {
                this.workflowRunResults = [] as any;
                for (let item of _data["workflowRunResults"])
                    this.workflowRunResults!.push(WorkflowRunResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GitHubWorkflowRunResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GitHubWorkflowRunResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repositoryName"] = this.repositoryName;
        data["buildCount"] = this.buildCount;
        if (Array.isArray(this.workflowRunResults)) {
            data["workflowRunResults"] = [];
            for (let item of this.workflowRunResults)
                data["workflowRunResults"].push(item ? item.toJSON() : undefined as any);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IGitHubWorkflowRunResponse extends IResponseBase {
    repositoryName?: string;
    buildCount?: number;
    workflowRunResults?: WorkflowRunResult[];
}

export class WorkflowRunResult implements IWorkflowRunResult {
    branchName?: string;
    runNumber?: number;
    buildTrigger?: string;
    commitMessage?: string;
    buildStatus?: string;
    buildConclusion?: string;
    createdDate?: string;
    updatedDate?: string;
    workflowUrl?: string;
    authorName?: string;

    constructor(data?: IWorkflowRunResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.branchName = _data["branchName"];
            this.runNumber = _data["runNumber"];
            this.buildTrigger = _data["buildTrigger"];
            this.commitMessage = _data["commitMessage"];
            this.buildStatus = _data["buildStatus"];
            this.buildConclusion = _data["buildConclusion"];
            this.createdDate = _data["createdDate"];
            this.updatedDate = _data["updatedDate"];
            this.workflowUrl = _data["workflowUrl"];
            this.authorName = _data["authorName"];
        }
    }

    static fromJS(data: any): WorkflowRunResult {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowRunResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchName"] = this.branchName;
        data["runNumber"] = this.runNumber;
        data["buildTrigger"] = this.buildTrigger;
        data["commitMessage"] = this.commitMessage;
        data["buildStatus"] = this.buildStatus;
        data["buildConclusion"] = this.buildConclusion;
        data["createdDate"] = this.createdDate;
        data["updatedDate"] = this.updatedDate;
        data["workflowUrl"] = this.workflowUrl;
        data["authorName"] = this.authorName;
        return data;
    }
}

export interface IWorkflowRunResult {
    branchName?: string;
    runNumber?: number;
    buildTrigger?: string;
    commitMessage?: string;
    buildStatus?: string;
    buildConclusion?: string;
    createdDate?: string;
    updatedDate?: string;
    workflowUrl?: string;
    authorName?: string;
}

export class GetWorkflowResultsRequest implements IGetWorkflowResultsRequest {
    repositoryName?: string;
    repositoryOwner?: string;

    constructor(data?: IGetWorkflowResultsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repositoryName = _data["repositoryName"];
            this.repositoryOwner = _data["repositoryOwner"];
        }
    }

    static fromJS(data: any): GetWorkflowResultsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkflowResultsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repositoryName"] = this.repositoryName;
        data["repositoryOwner"] = this.repositoryOwner;
        return data;
    }
}

export interface IGetWorkflowResultsRequest {
    repositoryName?: string;
    repositoryOwner?: string;
}

export class GitStatusResponse extends ResponseBase implements IGitStatusResponse {
    statusElements?: RepositoryStatusElement[];

    constructor(data?: IGitStatusResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["statusElements"])) {
                this.statusElements = [] as any;
                for (let item of _data["statusElements"])
                    this.statusElements!.push(RepositoryStatusElement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GitStatusResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GitStatusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statusElements)) {
            data["statusElements"] = [];
            for (let item of this.statusElements)
                data["statusElements"].push(item ? item.toJSON() : undefined as any);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IGitStatusResponse extends IResponseBase {
    statusElements?: RepositoryStatusElement[];
}

export class RepositoryStatusElement extends ChasmaXmlBase implements IRepositoryStatusElement {
    repositoryId?: string;
    filePath?: string;
    state?: FileStatus;
    isStaged?: boolean;

    constructor(data?: IRepositoryStatusElement) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.repositoryId = _data["repositoryId"];
            this.filePath = _data["filePath"];
            this.state = _data["state"];
            this.isStaged = _data["isStaged"];
        }
    }

    static fromJS(data: any): RepositoryStatusElement {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryStatusElement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repositoryId"] = this.repositoryId;
        data["filePath"] = this.filePath;
        data["state"] = this.state;
        data["isStaged"] = this.isStaged;
        super.toJSON(data);
        return data;
    }
}

export interface IRepositoryStatusElement extends IChasmaXmlBase {
    repositoryId?: string;
    filePath?: string;
    state?: FileStatus;
    isStaged?: boolean;
}

/** Calculated status of a filepath in the working directory considering the current Index and the Head. */
export enum FileStatus {
    Unaltered = 0,
    NewInIndex = 1,
    ModifiedInIndex = 2,
    DeletedFromIndex = 4,
    RenamedInIndex = 8,
    TypeChangeInIndex = 16,
    NewInWorkdir = 128,
    ModifiedInWorkdir = 256,
    DeletedFromWorkdir = 512,
    TypeChangeInWorkdir = 1024,
    RenamedInWorkdir = 2048,
    Unreadable = 4096,
    Ignored = 16384,
    Conflicted = 32768,
    Nonexistent = -2147483648,
}

export class GitStatusRequest extends ChasmaXmlBase implements IGitStatusRequest {
    repositoryId?: string;

    constructor(data?: IGitStatusRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.repositoryId = _data["repositoryId"];
        }
    }

    static fromJS(data: any): GitStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GitStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repositoryId"] = this.repositoryId;
        super.toJSON(data);
        return data;
    }
}

export interface IGitStatusRequest extends IChasmaXmlBase {
    repositoryId?: string;
}

export class ApplyStagingActionResponse extends ResponseBase implements IApplyStagingActionResponse {
    statusElements?: RepositoryStatusElement[];

    constructor(data?: IApplyStagingActionResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["statusElements"])) {
                this.statusElements = [] as any;
                for (let item of _data["statusElements"])
                    this.statusElements!.push(RepositoryStatusElement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplyStagingActionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyStagingActionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statusElements)) {
            data["statusElements"] = [];
            for (let item of this.statusElements)
                data["statusElements"].push(item ? item.toJSON() : undefined as any);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IApplyStagingActionResponse extends IResponseBase {
    statusElements?: RepositoryStatusElement[];
}

export class ApplyStagingActionRequest extends ChasmaXmlBase implements IApplyStagingActionRequest {
    repoKey?: string;
    fileName?: string;
    isStaging?: boolean;

    constructor(data?: IApplyStagingActionRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.repoKey = _data["repoKey"];
            this.fileName = _data["fileName"];
            this.isStaging = _data["isStaging"];
        }
    }

    static fromJS(data: any): ApplyStagingActionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyStagingActionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repoKey"] = this.repoKey;
        data["fileName"] = this.fileName;
        data["isStaging"] = this.isStaging;
        super.toJSON(data);
        return data;
    }
}

export interface IApplyStagingActionRequest extends IChasmaXmlBase {
    repoKey?: string;
    fileName?: string;
    isStaging?: boolean;
}

export class UserAccountModel implements IUserAccountModel {
    id?: number;
    name?: string;
    userName?: string;
    password?: string;
    salt?: string;

    constructor(data?: IUserAccountModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.salt = _data["salt"];
        }
    }

    static fromJS(data: any): UserAccountModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserAccountModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["salt"] = this.salt;
        return data;
    }
}

export interface IUserAccountModel {
    id?: number;
    name?: string;
    userName?: string;
    password?: string;
    salt?: string;
}

export class LoginResponse extends ResponseBase implements ILoginResponse {
    userName?: string;
    userId?: number;

    constructor(data?: ILoginResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userName = _data["userName"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userId"] = this.userId;
        super.toJSON(data);
        return data;
    }
}

export interface ILoginResponse extends IResponseBase {
    userName?: string;
    userId?: number;
}

export class LoginRequest extends ChasmaXmlBase implements ILoginRequest {
    userName?: string;
    password?: string;

    constructor(data?: ILoginRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        super.toJSON(data);
        return data;
    }
}

export interface ILoginRequest extends IChasmaXmlBase {
    userName?: string;
    password?: string;
}

export class AddUserResponse extends ResponseBase implements IAddUserResponse {
    userName?: string;

    constructor(data?: IAddUserResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): AddUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        super.toJSON(data);
        return data;
    }
}

export interface IAddUserResponse extends IResponseBase {
    userName?: string;
}

export class AddUserRequest implements IAddUserRequest {
    name?: string;
    userName?: string;
    password?: string;

    constructor(data?: IAddUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AddUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface IAddUserRequest {
    name?: string;
    userName?: string;
    password?: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}